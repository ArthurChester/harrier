{"remainingRequest":"D:\\WorkSpace\\IdeaProjects\\harrier\\harrier-ui\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\WorkSpace\\IdeaProjects\\harrier\\harrier-ui\\src\\components\\s-tree-table\\s-tree-table.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\WorkSpace\\IdeaProjects\\harrier\\harrier-ui\\src\\components\\s-tree-table\\s-tree-table.vue","mtime":1681468306478},{"path":"D:\\WorkSpace\\IdeaProjects\\harrier\\harrier-ui\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\WorkSpace\\IdeaProjects\\harrier\\harrier-ui\\node_modules\\babel-loader\\lib\\index.js","mtime":456789000000},{"path":"D:\\WorkSpace\\IdeaProjects\\harrier\\harrier-ui\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\WorkSpace\\IdeaProjects\\harrier\\harrier-ui\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["\r\nimport tableHead from \"./table-head.vue\";\r\nimport tableBody from \"./table-body.vue\";\r\nimport Spin from \"iview/src/components/spin/spin.vue\";\r\nimport {\r\n  oneOf,\r\n  getStyle,\r\n  deepCopy,\r\n  getScrollBarSize\r\n} from \"iview/src/utils/assist\";\r\nimport { on, off } from \"iview/src/utils/dom\";\r\nimport Csv from \"iview/src/utils/csv\";\r\nimport ExportCsv from \"./export-csv\";\r\nimport Locale from \"iview/src/mixins/locale\";\r\nimport elementResizeDetectorMaker from \"element-resize-detector\";\r\n\r\nconst prefixCls = \"ivu-table\";\r\n\r\nlet rowKey = 1;\r\nlet columnKey = 1;\r\n\r\nexport default {\r\n  name: \"STreeTable\",\r\n  mixins: [Locale],\r\n  components: { tableHead, tableBody, Spin },\r\n  props: {\r\n    data: {\r\n      type: Array,\r\n      default() {\r\n        return [];\r\n      }\r\n    },\r\n    columns: {\r\n      type: Array,\r\n      default() {\r\n        return [];\r\n      }\r\n    },\r\n    size: {\r\n      validator(value) {\r\n        return oneOf(value, [\"small\", \"large\", \"default\"]);\r\n      }\r\n    },\r\n    width: {\r\n      type: [Number, String]\r\n    },\r\n    height: {\r\n      type: [Number, String]\r\n    },\r\n    stripe: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    border: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    showHeader: {\r\n      type: Boolean,\r\n      default: true\r\n    },\r\n    highlightRow: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    rowClassName: {\r\n      type: Function,\r\n      default() {\r\n        return \"\";\r\n      }\r\n    },\r\n    context: {\r\n      type: Object\r\n    },\r\n    noDataText: {\r\n      type: String\r\n    },\r\n    noFilteredDataText: {\r\n      type: String\r\n    },\r\n    disabledHover: {\r\n      type: Boolean\r\n    },\r\n    loading: {\r\n      type: Boolean,\r\n      default: false\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      ready: false,\r\n      tableWidth: 0,\r\n      columnsWidth: {},\r\n      prefixCls: prefixCls,\r\n      compiledUids: [],\r\n      objData: this.makeObjData(), // checkbox or highlight-row\r\n      rebuildData: [], // for sort or filter\r\n      cloneColumns: this.makeColumns(),\r\n      showSlotHeader: true,\r\n      showSlotFooter: true,\r\n      bodyHeight: 0,\r\n      bodyRealHeight: 0,\r\n      scrollBarWidth: getScrollBarSize(),\r\n      currentContext: this.context\r\n    };\r\n  },\r\n  computed: {\r\n    localeNoDataText() {\r\n      // if (this.noDataText === undefined) {\r\n      //   return this.t(\"i.table.noDataText\");\r\n      // } else {\r\n      //   return this.noDataText;\r\n      // }\r\n      return this.noDataText;\r\n    },\r\n    localeNoFilteredDataText() {\r\n      // if (this.noFilteredDataText === undefined) {\r\n      //   return this.t(\"i.table.noFilteredDataText\");\r\n      // } else {\r\n      //   return this.noFilteredDataText;\r\n      // }\r\n      return this.noFilteredDataText;\r\n    },\r\n    wrapClasses() {\r\n      return [\r\n        `${prefixCls}-wrapper`,\r\n        {\r\n          [`${prefixCls}-hide`]: !this.ready,\r\n          [`${prefixCls}-with-header`]: this.showSlotHeader,\r\n          [`${prefixCls}-with-footer`]: this.showSlotFooter\r\n        }\r\n      ];\r\n    },\r\n    classes() {\r\n      return [\r\n        `${prefixCls}`,\r\n        {\r\n          [`${prefixCls}-${this.size}`]: !!this.size,\r\n          [`${prefixCls}-border`]: this.border,\r\n          [`${prefixCls}-stripe`]: this.stripe,\r\n          [`${prefixCls}-with-fixed-top`]: !!this.height\r\n        }\r\n      ];\r\n    },\r\n    fixedHeaderClasses() {\r\n      return [\r\n        `${prefixCls}-fixed-header`,\r\n        {\r\n          [`${prefixCls}-fixed-header-with-empty`]: !this.rebuildData.length\r\n        }\r\n      ];\r\n    },\r\n    styles() {\r\n      let style = {};\r\n      if (this.height) {\r\n        const height =\r\n          this.isLeftFixed || this.isRightFixed\r\n            ? parseInt(this.height) + this.scrollBarWidth\r\n            : parseInt(this.height);\r\n        style.height = `${height}px`;\r\n      }\r\n      if (this.width) style.width = `${this.width}px`;\r\n      return style;\r\n    },\r\n    tableStyle() {\r\n      let style = {};      \r\n      if (this.tableWidth !== 0) {\r\n        let width = \"\";\r\n        if (this.bodyHeight === 0) {\r\n          width = this.tableWidth;\r\n        } else {\r\n          if (this.bodyHeight > this.bodyRealHeight) {\r\n            width = this.tableWidth;\r\n          } else {\r\n            width = this.tableWidth - this.scrollBarWidth;\r\n          }\r\n        }\r\n        //                    const width = this.bodyHeight === 0 ? this.tableWidth : this.tableWidth - this.scrollBarWidth;\r\n        style.width = `${width}px`;\r\n        // console.log(style.width)\r\n        // style.width = 'auto'\r\n      }\r\n      return style;\r\n    },\r\n    fixedTableStyle() {\r\n      let style = {};\r\n      let width = 0;\r\n      this.leftFixedColumns.forEach(col => {\r\n        if (col.fixed && col.fixed === \"left\") width += col._width;\r\n      });\r\n      style.width = `${width}px`;\r\n      return style;\r\n    },\r\n    fixedRightTableStyle() {\r\n      let style = {};\r\n      let width = 0;\r\n      this.rightFixedColumns.forEach(col => {\r\n        if (col.fixed && col.fixed === \"right\") width += col._width;\r\n      });\r\n      width += this.scrollBarWidth;\r\n      style.width = `${width}px`;\r\n      return style;\r\n    },\r\n    bodyStyle() {\r\n      let style = {};\r\n      if (this.bodyHeight !== 0) {\r\n        // add a height to resolve scroll bug when browser has a scrollBar in fixed type and height prop\r\n        const height =\r\n          this.isLeftFixed || this.isRightFixed\r\n            ? this.bodyHeight + this.scrollBarWidth\r\n            : this.bodyHeight;\r\n        style.height = `${height}px`;\r\n      }\r\n      return style;\r\n    },\r\n    fixedBodyStyle() {\r\n      let style = {};\r\n      if (this.bodyHeight !== 0) {\r\n        let height = this.bodyHeight + this.scrollBarWidth - 1;\r\n\r\n        // #2102 里，如果 Table 没有设置 width，而是集成父级的 width，固定列也应该不包含滚动条高度，所以这里直接计算表格宽度\r\n        const tableWidth = parseInt(getStyle(this.$el, \"width\")) - 1;\r\n        if (\r\n          (this.width && this.width < this.tableWidth) ||\r\n          tableWidth < this.tableWidth\r\n        ) {\r\n          height = this.bodyHeight;\r\n        }\r\n        //                    style.height = this.scrollBarWidth > 0 ? `${this.bodyHeight}px` : `${this.bodyHeight - 1}px`;\r\n        style.height =\r\n          this.scrollBarWidth > 0 ? `${height}px` : `${height - 1}px`;\r\n      }\r\n      return style;\r\n    },\r\n    leftFixedColumns() {\r\n      let left = [];\r\n      let other = [];\r\n      this.cloneColumns.forEach(col => {\r\n        if (col.fixed && col.fixed === \"left\") {\r\n          left.push(col);\r\n        } else {\r\n          other.push(col);\r\n        }\r\n      });\r\n      return left.concat(other);\r\n    },\r\n    rightFixedColumns() {\r\n      let right = [];\r\n      let other = [];\r\n      this.cloneColumns.forEach(col => {\r\n        if (col.fixed && col.fixed === \"right\") {\r\n          right.push(col);\r\n        } else {\r\n          other.push(col);\r\n        }\r\n      });\r\n      return right.concat(other);\r\n    },\r\n    isLeftFixed() {\r\n      return this.columns.some(col => col.fixed && col.fixed === \"left\");\r\n    },\r\n    isRightFixed() {\r\n      return this.columns.some(col => col.fixed && col.fixed === \"right\");\r\n    }\r\n  },\r\n  methods: {\r\n    rowClsName(index) {\r\n      return this.rowClassName(this.data[index], index);\r\n    },\r\n    handleResize() {\r\n    this.$nextTick(() => {\r\n      let tableWidth = 0;\r\n      const allWidth = !this.columns.some(cell => !cell.width); // each column set a width\r\n      if (allWidth) {\r\n        this.tableWidth = this.columns\r\n          .map(cell => cell.width)\r\n          .reduce((a, b) => a + b, 0);\r\n      } \r\n      //else {\r\n        // this.tableWidth = parseInt(getStyle(this.$refs.body, \"width\")) - 1;\r\n      //}        \r\n      // if(this.tableWidth!=0 )//非0,说明已经计算好了，不要再重新计算了\r\n      //     return\r\n      // this.columnsWidth = {};\r\n\r\n      if (!this.$refs.tbody) return;\r\n      this.$nextTick(() => {\r\n        let columnsWidth = {};\r\n        let autoWidthIndex = -1;\r\n        if (allWidth)\r\n          autoWidthIndex = this.cloneColumns.findIndex(cell => !cell.width); //todo 这行可能有问题                      \r\n\r\n        //\r\n        const $warrperdiv = this.$refs.header.parentNode.parentNode;\r\n    \r\n        if (this.data.length) {\r\n          const $bodyTr = this.$refs.tbody.$el.querySelectorAll(\"tbody tr\");\r\n          const $headTr = this.$refs.header.children[0].querySelectorAll(\"tr\");\r\n          // const $headTr = this.$refs.thead.$el.querySelectorAll(\"thead tr\");            \r\n                     \r\n          let $td = $headTr[0].children;                         \r\n          let autoColNum = $td.length;\r\n          //从后往前找到不是fixed width的第一个，将最后的宽度倒减给它，保证宽度一致性\r\n          let lastAutoWidth;\r\n          let lastIndex;\r\n          let autoTotalMinWidth = parseInt(getStyle($warrperdiv, \"width\"));;\r\n          for (let i = 0; i < $td.length; i++) {\r\n            let column = this.cloneColumns[i];\r\n            if (column.width) {\r\n              autoTotalMinWidth = autoTotalMinWidth-column.width;\r\n              autoColNum--;\r\n            }else{\r\n              lastIndex = i;//last index\r\n            }\r\n          }\r\n\r\n          let minWidthperCol = Math.floor(autoTotalMinWidth/autoColNum-10);\r\n        //   let minWidthperCol = autoTotalMinWidth/autoColNum-10;\r\n          \r\n          for (let j = 0; j < $td.length; j++) {\r\n            // can not use forEach in Firefox\r\n            let column2 = this.cloneColumns[j];\r\n            let width = parseInt(getStyle($td[j], \"width\")) + 0;\r\n            // let width = Math.floor(getStyle($td[j], \"width\")) + 1;\r\n            //默认Auto\r\n            width = width>minWidthperCol?width:minWidthperCol;                          \r\n            if (column2.width) {//固定宽度\r\n              width = column2.width;\r\n            }else if(j==lastIndex){\r\n              width = autoTotalMinWidth-5;//最后一列就是剩下的宽度\r\n            }else {//自动宽度\r\n              autoTotalMinWidth -= width\r\n            }              \r\n            this.cloneColumns[j]._width = width;            \r\n            columnsWidth[column2._index] = {\r\n              width: width\r\n            };\r\n          }\r\n          \r\n          if($bodyTr.length!=0){\r\n            $td = $bodyTr[0].children;              \r\n            for(let j=0;j<$td.length;j++){                  \r\n                let column = this.cloneColumns[j];                  \r\n                let width = parseInt(getStyle($td[j], \"width\")) + 0;\r\n                // console.log('body['+j+']width=' +width)\r\n                if (column.width) width = column.width;                  \r\n                width = width > this.cloneColumns[j]._width?width:this.cloneColumns[j]._width;//使用大的width                                    \r\n                this.cloneColumns[j]._width = width;                  \r\n                columnsWidth[column._index] = {\r\n                   width: width\r\n                };                  \r\n            }\r\n          }\r\n\r\n          //计算tableWidth长度\r\n          for(let j=0;j<$td.length;j++){ \r\n            let column = this.cloneColumns[j];\r\n            tableWidth+=columnsWidth[column._index].width\r\n          }\r\n          \r\n          this.columnsWidth = columnsWidth;\r\n          // console.log(columnsWidth)\r\n           this.tableWidth = tableWidth;\r\n        }     \r\n         \r\n          //console.log(\"this.tableWidth=\"+this.tableWidth)\r\n      });\r\n      // get table real height,for fixed when set height prop,but height < table's height,show scrollBarWidth\r\n      this.bodyRealHeight = parseInt(\r\n        getStyle(this.$refs.tbody.$el, \"height\")\r\n      );\r\n    });\r\n    },\r\n    handleMouseIn(_index) {\r\n      if (this.disabledHover) return;\r\n      if (this.objData[_index]._isHover) return;\r\n      this.objData[_index]._isHover = true;\r\n    },\r\n    handleMouseOut(_index) {\r\n      if (this.disabledHover) return;\r\n      this.objData[_index]._isHover = false;\r\n    },\r\n    // 通用处理 highlightCurrentRow 和 clearCurrentRow\r\n    handleCurrentRow(type, _index) {\r\n      let oldIndex = -1;\r\n      for (let i in this.objData) {\r\n        if (this.objData[i]._isHighlight) {\r\n          oldIndex = parseInt(i);\r\n          this.objData[i]._isHighlight = false;\r\n        }\r\n      }\r\n      if (type === \"highlight\") this.objData[_index]._isHighlight = true;\r\n      const oldData =\r\n        oldIndex < 0\r\n          ? null\r\n          : JSON.parse(JSON.stringify(this.objData[_index].ref));\r\n      const newData =\r\n        type === \"highlight\"\r\n          ? JSON.parse(JSON.stringify(this.objData[_index].ref))\r\n          : null;\r\n      this.$emit(\"on-current-change\", newData, oldData);\r\n    },\r\n    highlightCurrentRow(_index) {\r\n      if (!this.highlightRow || this.objData[_index]._isHighlight) return;\r\n      this.handleCurrentRow(\"highlight\", _index);\r\n    },\r\n    clearCurrentRow() {\r\n      if (!this.highlightRow) return;\r\n      this.handleCurrentRow(\"clear\");\r\n    },\r\n    clickCurrentRow(_index) {\r\n      this.highlightCurrentRow(_index);\r\n      // console.log(this.objData[_index]);\r\n      this.$emit(\"on-row-click\", this.objData[_index].ref, _index);\r\n    },\r\n    dblclickCurrentRow(_index) {\r\n      this.highlightCurrentRow(_index);\r\n      this.$emit(\"on-row-dblclick\", this.objData[_index].ref, _index);\r\n    },\r\n    getSelection() {\r\n      let selections = [];\r\n      let selectionIndexes = [];\r\n      for (let i in this.objData) {\r\n        if (this.objData[i]._isChecked) {\r\n          selectionIndexes.push(parseInt(i));\r\n          selections.push(this.objData[i].ref);\r\n        }\r\n      }\r\n      return selections;\r\n    },\r\n    toggleSelect(_index) {\r\n      let data = {};\r\n\r\n      for (let i in this.objData) {\r\n        if (parseInt(i) === _index) {\r\n          data = this.objData[i];\r\n          break;\r\n        }\r\n      }\r\n      const status = !data._isChecked;\r\n\r\n      this.objData[_index]._isChecked = status;\r\n\r\n      const selection = this.getSelection();\r\n      this.$emit(\r\n        status ? \"on-select\" : \"on-select-cancel\",\r\n        selection,\r\n        this.objData[_index].ref\r\n      );\r\n      this.$emit(\"on-selection-change\", selection);\r\n    },\r\n    toggleExpand(_index) {\r\n      let data = {};\r\n      for (let i in this.objData) {\r\n        if (parseInt(i) === _index) {\r\n          data = this.objData[i];\r\n          break;\r\n        }\r\n      }\r\n      const status = !data._isExpanded;\r\n      this.objData[_index]._isExpanded = status;\r\n      this.$emit(\r\n        \"on-expand\",\r\n        JSON.parse(JSON.stringify(this.objData[_index].ref)),\r\n        status\r\n      );\r\n    },\r\n    toggleTree(_index) {\r\n      let data = {};\r\n      // let _currentIndex = _index;\r\n      for (let i in this.objData) {\r\n        if (parseInt(i) === _index) {\r\n          data = this.objData[i];\r\n          break;\r\n        }\r\n      }\r\n      const status = !data._isFolded;\r\n      this.objData[_index]._isFolded = status;\r\n      //modify origin data fold status 修改data时不再refreshfold状态\r\n      this.rebuildData[_index].ref._unfolded = !status;\r\n      //如果父节点fold，则它的children也要全部fold,直接修改源数据\r\n      // debugger\r\n      if (this.objData[_index]._isFolded) {\r\n        this.cascadeFold(this.rebuildData[_index].ref);\r\n        this.cascadeFold2(this.objData[_index]);\r\n      }\r\n      this.$emit(\"unfold-tree\", this.objData[_index].ref, status);\r\n    },\r\n    cascadeFold(objData) {\r\n      let children = objData.children;\r\n      if (children == null || children == undefined || children.length == 0) {\r\n        return;\r\n      }\r\n      for (let child of children) {\r\n        if (child != null) {\r\n          child._unfolded = false;\r\n        }\r\n        this.cascadeFold(child);\r\n      }\r\n    },\r\n    // 折叠子级树\r\n    cascadeFold2(objData) {\r\n      let children = objData.children;\r\n      if (children == null || children == undefined || children.length == 0) {\r\n        return;\r\n      }\r\n      for (let child of children) {\r\n        if (child != null) {\r\n          child._isFolded = true;\r\n        }\r\n        this.cascadeFold2(child);\r\n      }\r\n    },\r\n    selectAll(status) {\r\n      for (const data of this.rebuildData) {\r\n        if (this.objData[data._index]._isDisabled) {\r\n          continue;\r\n        } else {\r\n          this.objData[data._index]._isChecked = status;\r\n        }\r\n      }\r\n      const selection = this.getSelection();\r\n      if (status) {\r\n        this.$emit(\"on-select-all\", selection);\r\n      }\r\n      this.$emit(\"on-selection-change\", selection);\r\n    },\r\n    fixedHeader() {\r\n      if (this.height) {\r\n        this.$nextTick(() => {\r\n          const titleHeight =\r\n            parseInt(getStyle(this.$refs.title, \"height\")) || 0;\r\n          const headerHeight =\r\n            parseInt(getStyle(this.$refs.header, \"height\")) || 0;\r\n          const footerHeight =\r\n            parseInt(getStyle(this.$refs.footer, \"height\")) || 0;\r\n          this.bodyHeight =\r\n            this.height - titleHeight - headerHeight - footerHeight;\r\n        });\r\n      } else {\r\n        this.bodyHeight = 0;\r\n      }\r\n    },\r\n    hideColumnFilter() {\r\n      this.cloneColumns.forEach(col => (col._filterVisible = false));\r\n    },\r\n    handleBodyScroll(event) {\r\n      if (this.showHeader)\r\n        this.$refs.header.scrollLeft = event.target.scrollLeft;\r\n      if (this.isLeftFixed)\r\n        this.$refs.fixedBody.scrollTop = event.target.scrollTop;\r\n      if (this.isRightFixed)\r\n        this.$refs.fixedRightBody.scrollTop = event.target.scrollTop;\r\n      this.hideColumnFilter();\r\n    },\r\n    handleMouseWheel(event) {\r\n      const deltaX = event.deltaX;\r\n      const $body = this.$refs.body;\r\n\r\n      if (deltaX > 0) {\r\n        $body.scrollLeft = $body.scrollLeft + 10;\r\n      } else {\r\n        $body.scrollLeft = $body.scrollLeft - 10;\r\n      }\r\n    },\r\n    sortData(data, type, index) {\r\n      const key = this.cloneColumns[index].key;\r\n      data.sort((a, b) => {\r\n        if (this.cloneColumns[index].sortMethod) {\r\n          return this.cloneColumns[index].sortMethod(a[key], b[key], type);\r\n        } else {\r\n          if (type === \"asc\") {\r\n            return a[key] > b[key] ? 1 : -1;\r\n          } else if (type === \"desc\") {\r\n            return a[key] < b[key] ? 1 : -1;\r\n          }\r\n        }\r\n      });\r\n      return data;\r\n    },\r\n    handleSort(_index, type) {\r\n      const index = this.GetOriginalIndex(_index);\r\n      this.cloneColumns.forEach(col => (col._sortType = \"normal\"));\r\n\r\n      const key = this.cloneColumns[index].key;\r\n      if (this.cloneColumns[index].sortable !== \"custom\") {\r\n        // custom is for remote sort\r\n        if (type === \"normal\") {\r\n          this.rebuildData = this.makeDataWithFilter();\r\n        } else {\r\n          this.rebuildData = this.sortData(this.rebuildData, type, index);\r\n        }\r\n      }\r\n      this.cloneColumns[index]._sortType = type;\r\n\r\n      this.$emit(\"on-sort-change\", {\r\n        column: JSON.parse(\r\n          JSON.stringify(this.columns[this.cloneColumns[index]._index])\r\n        ),\r\n        key: key,\r\n        order: type\r\n      });\r\n    },\r\n    handleFilterHide(index) {\r\n      // clear checked that not filter now\r\n      if (!this.cloneColumns[index]._isFiltered)\r\n        this.cloneColumns[index]._filterChecked = [];\r\n    },\r\n    filterData(data, column) {\r\n      return data.filter(row => {\r\n        //如果定义了远程过滤方法则忽略此方法\r\n        if (typeof column.filterRemote === \"function\") return true;\r\n\r\n        let status = !column._filterChecked.length;\r\n        for (let i = 0; i < column._filterChecked.length; i++) {\r\n          status = column.filterMethod(column._filterChecked[i], row);\r\n          if (status) break;\r\n        }\r\n        return status;\r\n      });\r\n    },\r\n    filterOtherData(data, index) {\r\n      let column = this.cloneColumns[index];\r\n      if (typeof column.filterRemote === \"function\") {\r\n        column.filterRemote.call(\r\n          this.$parent,\r\n          column._filterChecked,\r\n          column.key,\r\n          column\r\n        );\r\n      }\r\n\r\n      this.cloneColumns.forEach((col, colIndex) => {\r\n        if (colIndex !== index) {\r\n          data = this.filterData(data, col);\r\n        }\r\n      });\r\n      return data;\r\n    },\r\n    handleFilter(index) {\r\n      const column = this.cloneColumns[index];\r\n      let filterData = this.makeDataWithSort();\r\n\r\n      // filter others first, after filter this column\r\n      filterData = this.filterOtherData(filterData, index);\r\n      this.rebuildData = this.filterData(filterData, column);\r\n\r\n      this.cloneColumns[index]._isFiltered = true;\r\n      this.cloneColumns[index]._filterVisible = false;\r\n      this.$emit(\"on-filter-change\", column);\r\n    },\r\n    /**\r\n     * #2832\r\n     * 应该区分当前表头的 column 是左固定还是右固定\r\n     * 否则执行到 $parent 时，方法的 index 与 cloneColumns 的 index 是不对应的\r\n     * 左固定和右固定，要区分对待\r\n     * 所以，此方法用来获取正确的 index\r\n     * */\r\n    GetOriginalIndex(_index) {\r\n      return this.cloneColumns.findIndex(item => item._index === _index);\r\n    },\r\n    handleFilterSelect(_index, value) {\r\n      const index = this.GetOriginalIndex(_index);\r\n      this.cloneColumns[index]._filterChecked = [value];\r\n      this.handleFilter(index);\r\n    },\r\n    handleFilterReset(_index) {\r\n      const index = this.GetOriginalIndex(_index);\r\n      this.cloneColumns[index]._isFiltered = false;\r\n      this.cloneColumns[index]._filterVisible = false;\r\n      this.cloneColumns[index]._filterChecked = [];\r\n\r\n      let filterData = this.makeDataWithSort();\r\n      filterData = this.filterOtherData(filterData, index);\r\n      this.rebuildData = filterData;\r\n      this.$emit(\"on-filter-change\", this.cloneColumns[index]);\r\n    },\r\n    makeDataWithSort() {\r\n      let data = this.makeData();\r\n      let sortType = \"normal\";\r\n      let sortIndex = -1;\r\n      let isCustom = false;\r\n\r\n      for (let i = 0; i < this.cloneColumns.length; i++) {\r\n        if (this.cloneColumns[i]._sortType !== \"normal\") {\r\n          sortType = this.cloneColumns[i]._sortType;\r\n          sortIndex = i;\r\n          isCustom = this.cloneColumns[i].sortable === \"custom\";\r\n          break;\r\n        }\r\n      }\r\n      if (sortType !== \"normal\" && !isCustom)\r\n        data = this.sortData(data, sortType, sortIndex);\r\n      return data;\r\n    },\r\n    makeDataWithFilter() {\r\n      let data = this.makeData();\r\n      this.cloneColumns.forEach(col => (data = this.filterData(data, col)));\r\n      return data;\r\n    },\r\n    makeDataWithSortAndFilter() {\r\n      let data = this.makeDataWithSort();\r\n      this.cloneColumns.forEach(col => (data = this.filterData(data, col)));\r\n      return data;\r\n    },\r\n    addRowIsAttribute(newRow) {\r\n      newRow._isHover = false;\r\n      if (newRow._disabled) {\r\n        newRow._isDisabled = newRow._disabled;\r\n      } else {\r\n        newRow._isDisabled = false;\r\n      }\r\n      if (newRow._checked) {\r\n        newRow._isChecked = newRow._checked;\r\n      } else {\r\n        newRow._isChecked = false;\r\n      }\r\n      if (newRow._expanded) {\r\n        newRow._isExpanded = newRow._expanded;\r\n      } else {\r\n        newRow._isExpanded = false;\r\n      }\r\n      if (newRow._highlight) {\r\n        newRow._isHighlight = newRow._highlight;\r\n      } else {\r\n        newRow._isHighlight = false;\r\n      }\r\n      if (newRow._unfolded) {\r\n        newRow._isFolded = !newRow._unfolded;\r\n      } else {\r\n        newRow._isFolded = true;\r\n      }\r\n      return newRow;\r\n    },\r\n    makeData() {\r\n      //创建表格Data\r\n      //makeData need to unfold the children node to table data\r\n      let root = this.data;\r\n      let data = [];\r\n      let dataRow;\r\n      let currentIndex = 0;\r\n      let rowKey = 0;\r\n      root.forEach((row, index) => {\r\n        if (row.hasOwnProperty(\"children\")) {\r\n          let treeStack = new Array();\r\n          let temp = { originData: row, makeData: null };\r\n          treeStack.push(temp);\r\n          //Deep fist travel children Tree\r\n          while (treeStack.length != 0) {\r\n            const obj = treeStack.pop();\r\n            const parentRow = obj.originData;\r\n            const dataRowParent = obj.makeData;\r\n            dataRow = this.deepCopyWithOutParent(parentRow);\r\n            if (typeof dataRowParent != \"undefined\" && dataRowParent != null) {\r\n              dataRowParent.children.push(dataRow);\r\n              dataRow.parent = dataRowParent;\r\n            }\r\n            dataRow._rowKey = rowKey++;\r\n            dataRow._index = currentIndex;\r\n            dataRow.ref = parentRow; //增加对原数据的引用，方便后续操作\r\n            data[currentIndex++] = dataRow;\r\n            if (parentRow.hasOwnProperty(\"children\")) {\r\n              dataRow.children = [];\r\n              for (let i = parentRow.children.length - 1; i >= 0; i--) {\r\n                treeStack.push({\r\n                  originData: parentRow.children[i],\r\n                  makeData: dataRow\r\n                });\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          dataRow = this.deepCopyWithOutParent(row);\r\n          dataRow._rowKey = rowKey++;\r\n          dataRow._index = currentIndex;\r\n          dataRow.ref = row; //增加对原数据的引用，方便后续操作\r\n          data[currentIndex++] = dataRow;\r\n        }\r\n      });\r\n      //   console.log(data);\r\n      return data;\r\n    },\r\n    makeObjData() {\r\n      // let data = {};\r\n      // let newIndex = 0;\r\n      // this.data.forEach((row, index) => {\r\n      //   let root = this.addRowIsAttribute(deepCopy(row));\r\n      //   root.ref = row;\r\n      //   if (root.hasOwnProperty(\"children\")) {\r\n      //     //遍历\r\n      //     let treeStack = new Array();\r\n      //     treeStack.push(root);\r\n      //     while (treeStack.length != 0) {\r\n      //       const parentRow = treeStack.pop();\r\n      //       data[newIndex] = this.addRowIsAttribute(deepCopy(parentRow)); //输出\r\n      //       // data[newIndex].ref = parentRow;\r\n      //       newIndex++;\r\n      //       if (parentRow.hasOwnProperty(\"children\")) {\r\n      //         //逆序遍历数组\r\n      //         for (let i = parentRow.children.length - 1; i >= 0; i--) {\r\n      //           parentRow.children[i].parent = parentRow;\r\n      //           treeStack.push(parentRow.children[i]);\r\n      //         }\r\n      //       }\r\n      //     }\r\n      //   } else {\r\n      //     data[newIndex++] = root;\r\n      //   }\r\n      //   //Deep fist travel children Tree\r\n      // });\r\n      // console.log(data);\r\n      let data = {};\r\n      this.makeData().forEach((row, index) => {\r\n        data[index] = this.addRowIsAttribute(row);\r\n      });\r\n      return data;\r\n    },\r\n    makeColumns() {\r\n      let columns = deepCopy(this.columns);\r\n      let left = [];\r\n      let right = [];\r\n      let center = [];\r\n\r\n      columns.forEach((column, index) => {\r\n        column._index = index;\r\n        column._columnKey = columnKey++;\r\n        column._width = column.width ? column.width : \"\"; // update in handleResize()\r\n        column._sortType = \"normal\";\r\n        column._filterVisible = false;\r\n        column._isFiltered = false;\r\n        column._filterChecked = [];\r\n\r\n        if (\"filterMultiple\" in column) {\r\n          column._filterMultiple = column.filterMultiple;\r\n        } else {\r\n          column._filterMultiple = true;\r\n        }\r\n        if (\"filteredValue\" in column) {\r\n          column._filterChecked = column.filteredValue;\r\n          column._isFiltered = true;\r\n        }\r\n\r\n        if (\"sortType\" in column) {\r\n          column._sortType = column.sortType;\r\n        }\r\n\r\n        if (column.fixed && column.fixed === \"left\") {\r\n          left.push(column);\r\n        } else if (column.fixed && column.fixed === \"right\") {\r\n          right.push(column);\r\n        } else {\r\n          center.push(column);\r\n        }\r\n      });\r\n      return left.concat(center).concat(right);\r\n    },\r\n    exportCsv(params) {\r\n      if (params.filename) {\r\n        if (params.filename.indexOf(\".csv\") === -1) {\r\n          params.filename += \".csv\";\r\n        }\r\n      } else {\r\n        params.filename = \"table.csv\";\r\n      }\r\n\r\n      let columns = [];\r\n      let datas = [];\r\n      if (params.columns && params.data) {\r\n        columns = params.columns;\r\n        datas = params.data;\r\n      } else {\r\n        columns = this.columns;\r\n        if (!(\"original\" in params)) params.original = true;\r\n        datas = params.original ? this.data : this.rebuildData;\r\n      }\r\n\r\n      let noHeader = false;\r\n      if (\"noHeader\" in params) noHeader = params.noHeader;\r\n\r\n      const data = Csv(columns, datas, params, noHeader);\r\n      if (params.callback) params.callback(data);\r\n      else ExportCsv.download(params.filename, data);\r\n    },\r\n    deepCopyWithOutParent(data) {\r\n      const t = this.typeOf(data);\r\n      let o;\r\n      if (t === \"array\") {\r\n        o = [];\r\n      } else if (t === \"object\") {\r\n        o = {};\r\n      } else {\r\n        return data;\r\n      }\r\n\r\n      if (t === \"array\") {\r\n        for (let i = 0; i < data.length; i++) {\r\n          o.push(this.deepCopyWithOutParent(data[i]));\r\n        }\r\n      } else if (t === \"object\") {\r\n        for (let i in data) {\r\n          if (i != \"parent\" && i != \"children\") {\r\n            o[i] = this.deepCopyWithOutParent(data[i]);\r\n          } else {\r\n            o[i] = data[i];\r\n          }\r\n        }\r\n      }\r\n      return o;\r\n    },\r\n    typeOf(obj) {\r\n      const toString = Object.prototype.toString;\r\n      const map = {\r\n        \"[object Boolean]\": \"boolean\",\r\n        \"[object Number]\": \"number\",\r\n        \"[object String]\": \"string\",\r\n        \"[object Function]\": \"function\",\r\n        \"[object Array]\": \"array\",\r\n        \"[object Date]\": \"date\",\r\n        \"[object RegExp]\": \"regExp\",\r\n        \"[object Undefined]\": \"undefined\",\r\n        \"[object Null]\": \"null\",\r\n        \"[object Object]\": \"object\"\r\n      };\r\n      return map[toString.call(obj)];\r\n    }\r\n  },\r\n  created() {\r\n    if (!this.context) this.currentContext = this.$parent;\r\n    this.showSlotHeader = this.$slots.header !== undefined;\r\n    this.showSlotFooter = this.$slots.footer !== undefined;\r\n    this.rebuildData = this.makeDataWithSortAndFilter();\r\n  },\r\n  mounted() {\r\n    this.handleResize();\r\n    this.fixedHeader();\r\n    this.$nextTick(() => (this.ready = true));\r\n\r\n    on(window, \"resize\", this.handleResize);\r\n    this.observer = elementResizeDetectorMaker();\r\n    this.observer.listenTo(this.$el, this.handleResize);\r\n\r\n    this.$on(\"on-visible-change\", val => {\r\n      if (val) {\r\n        this.handleResize();\r\n        this.fixedHeader();\r\n      }\r\n    });\r\n  },\r\n  beforeDestroy() {\r\n    off(window, \"resize\", this.handleResize);\r\n    this.observer.removeListener(this.$el, this.handleResize);\r\n  },\r\n  watch: {\r\n    data: {\r\n      handler() {\r\n        const oldDataLen = this.rebuildData.length;\r\n        this.objData = this.makeObjData();\r\n        this.rebuildData = this.makeDataWithSortAndFilter();\r\n        this.handleResize();\r\n        if (!oldDataLen) {\r\n          this.fixedHeader();\r\n        }\r\n      },\r\n      deep: true\r\n    },\r\n    columns: {\r\n      handler() {\r\n        // todo 这里有性能问题，可能是左右固定计算属性影响的\r\n        this.cloneColumns = this.makeColumns();\r\n        this.rebuildData = this.makeDataWithSortAndFilter();\r\n        this.handleResize();\r\n      },\r\n      deep: true\r\n    },\r\n    height() {\r\n      this.fixedHeader();\r\n    }\r\n  }\r\n};\r\n",{"version":3,"sources":["s-tree-table.vue"],"names":[],"mappings":";AA0FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"s-tree-table.vue","sourceRoot":"src/components/s-tree-table","sourcesContent":["<template>\r\n    <div :class=\"wrapClasses\" :style=\"styles\">\r\n        <div :class=\"classes\">\r\n            <div :class=\"[prefixCls + '-title']\" v-if=\"showSlotHeader\" ref=\"title\"><slot name=\"header\"></slot></div>\r\n            <div :class=\"[prefixCls + '-header']\" v-if=\"showHeader\" ref=\"header\" @mousewheel=\"handleMouseWheel\">\r\n                <table-head                    \r\n                    :prefix-cls=\"prefixCls\"\r\n                    :styleObject=\"tableStyle\"\r\n                    :columns=\"cloneColumns\"\r\n                    :obj-data=\"objData\"\r\n                    :columns-width=\"columnsWidth\"\r\n                    :data=\"rebuildData\"></table-head>\r\n            </div>\r\n            <div :class=\"[prefixCls + '-body']\" :style=\"bodyStyle\" ref=\"body\" @scroll=\"handleBodyScroll\"\r\n                v-show=\"!((!!localeNoDataText && (!data || data.length === 0)) || (!!localeNoFilteredDataText && (!rebuildData || rebuildData.length === 0)))\">\r\n                <table-body\r\n                    ref=\"tbody\"\r\n                    :prefix-cls=\"prefixCls\"\r\n                    :styleObject=\"tableStyle\"\r\n                    :columns=\"cloneColumns\"\r\n                    :data=\"rebuildData\"\r\n                    :columns-width=\"columnsWidth\"\r\n                    :obj-data=\"objData\"></table-body>\r\n            </div>\r\n            <div\r\n                :class=\"[prefixCls + '-tip']\"\r\n                v-show=\"((!!localeNoDataText && (!data || data.length === 0)) || (!!localeNoFilteredDataText && (!rebuildData || rebuildData.length === 0)))\">\r\n                <table cellspacing=\"0\" cellpadding=\"0\" border=\"0\">\r\n                    <tbody>\r\n                        <tr>\r\n                            <td :style=\"{ 'height': bodyStyle.height }\">\r\n                                <span v-html=\"localeNoDataText\" v-if=\"!data || data.length === 0\"></span>\r\n                                <span v-html=\"localeNoFilteredDataText\" v-else></span>\r\n                            </td>\r\n                        </tr>\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n            <div :class=\"[prefixCls + '-fixed']\" :style=\"fixedTableStyle\" v-if=\"isLeftFixed\">\r\n                <div :class=\"fixedHeaderClasses\" v-if=\"showHeader\">\r\n                    <table-head\r\n                        fixed=\"left\"\r\n                        :prefix-cls=\"prefixCls\"\r\n                        :styleObject=\"fixedTableStyle\"\r\n                        :columns=\"leftFixedColumns\"\r\n                        :obj-data=\"objData\"\r\n                        :columns-width=\"columnsWidth\"\r\n                        :data=\"rebuildData\"></table-head>\r\n                </div>\r\n                <div :class=\"[prefixCls + '-fixed-body']\" :style=\"fixedBodyStyle\" ref=\"fixedBody\">\r\n                    <table-body\r\n                        fixed=\"left\"\r\n                        :prefix-cls=\"prefixCls\"\r\n                        :styleObject=\"fixedTableStyle\"\r\n                        :columns=\"leftFixedColumns\"\r\n                        :data=\"rebuildData\"\r\n                        :columns-width=\"columnsWidth\"\r\n                        :obj-data=\"objData\"></table-body>\r\n                </div>\r\n            </div>\r\n            <div :class=\"[prefixCls + '-fixed-right']\" :style=\"fixedRightTableStyle\" v-if=\"isRightFixed\">\r\n                <div :class=\"fixedHeaderClasses\" v-if=\"showHeader\">\r\n                    <table-head\r\n                        fixed=\"right\"\r\n                        :prefix-cls=\"prefixCls\"\r\n                        :styleObject=\"fixedRightTableStyle\"\r\n                        :columns=\"rightFixedColumns\"\r\n                        :obj-data=\"objData\"\r\n                        :columns-width=\"columnsWidth\"\r\n                        :data=\"rebuildData\"></table-head>\r\n                </div>\r\n                <div :class=\"[prefixCls + '-fixed-body']\" :style=\"fixedBodyStyle\" ref=\"fixedRightBody\">\r\n                    <table-body\r\n                        fixed=\"right\"\r\n                        :prefix-cls=\"prefixCls\"\r\n                        :styleObject=\"fixedRightTableStyle\"\r\n                        :columns=\"rightFixedColumns\"\r\n                        :data=\"rebuildData\"\r\n                        :columns-width=\"columnsWidth\"\r\n                        :obj-data=\"objData\"></table-body>\r\n                </div>\r\n            </div>\r\n            <div :class=\"[prefixCls + '-footer']\" v-if=\"showSlotFooter\" ref=\"footer\"><slot name=\"footer\"></slot></div>\r\n        </div>\r\n        <Spin fix size=\"large\" v-if=\"loading\">\r\n            <slot name=\"loading\"></slot>\r\n        </Spin>\r\n    </div>\r\n</template>\r\n<script>\r\nimport tableHead from \"./table-head.vue\";\r\nimport tableBody from \"./table-body.vue\";\r\nimport Spin from \"iview/src/components/spin/spin.vue\";\r\nimport {\r\n  oneOf,\r\n  getStyle,\r\n  deepCopy,\r\n  getScrollBarSize\r\n} from \"iview/src/utils/assist\";\r\nimport { on, off } from \"iview/src/utils/dom\";\r\nimport Csv from \"iview/src/utils/csv\";\r\nimport ExportCsv from \"./export-csv\";\r\nimport Locale from \"iview/src/mixins/locale\";\r\nimport elementResizeDetectorMaker from \"element-resize-detector\";\r\n\r\nconst prefixCls = \"ivu-table\";\r\n\r\nlet rowKey = 1;\r\nlet columnKey = 1;\r\n\r\nexport default {\r\n  name: \"STreeTable\",\r\n  mixins: [Locale],\r\n  components: { tableHead, tableBody, Spin },\r\n  props: {\r\n    data: {\r\n      type: Array,\r\n      default() {\r\n        return [];\r\n      }\r\n    },\r\n    columns: {\r\n      type: Array,\r\n      default() {\r\n        return [];\r\n      }\r\n    },\r\n    size: {\r\n      validator(value) {\r\n        return oneOf(value, [\"small\", \"large\", \"default\"]);\r\n      }\r\n    },\r\n    width: {\r\n      type: [Number, String]\r\n    },\r\n    height: {\r\n      type: [Number, String]\r\n    },\r\n    stripe: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    border: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    showHeader: {\r\n      type: Boolean,\r\n      default: true\r\n    },\r\n    highlightRow: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    rowClassName: {\r\n      type: Function,\r\n      default() {\r\n        return \"\";\r\n      }\r\n    },\r\n    context: {\r\n      type: Object\r\n    },\r\n    noDataText: {\r\n      type: String\r\n    },\r\n    noFilteredDataText: {\r\n      type: String\r\n    },\r\n    disabledHover: {\r\n      type: Boolean\r\n    },\r\n    loading: {\r\n      type: Boolean,\r\n      default: false\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      ready: false,\r\n      tableWidth: 0,\r\n      columnsWidth: {},\r\n      prefixCls: prefixCls,\r\n      compiledUids: [],\r\n      objData: this.makeObjData(), // checkbox or highlight-row\r\n      rebuildData: [], // for sort or filter\r\n      cloneColumns: this.makeColumns(),\r\n      showSlotHeader: true,\r\n      showSlotFooter: true,\r\n      bodyHeight: 0,\r\n      bodyRealHeight: 0,\r\n      scrollBarWidth: getScrollBarSize(),\r\n      currentContext: this.context\r\n    };\r\n  },\r\n  computed: {\r\n    localeNoDataText() {\r\n      // if (this.noDataText === undefined) {\r\n      //   return this.t(\"i.table.noDataText\");\r\n      // } else {\r\n      //   return this.noDataText;\r\n      // }\r\n      return this.noDataText;\r\n    },\r\n    localeNoFilteredDataText() {\r\n      // if (this.noFilteredDataText === undefined) {\r\n      //   return this.t(\"i.table.noFilteredDataText\");\r\n      // } else {\r\n      //   return this.noFilteredDataText;\r\n      // }\r\n      return this.noFilteredDataText;\r\n    },\r\n    wrapClasses() {\r\n      return [\r\n        `${prefixCls}-wrapper`,\r\n        {\r\n          [`${prefixCls}-hide`]: !this.ready,\r\n          [`${prefixCls}-with-header`]: this.showSlotHeader,\r\n          [`${prefixCls}-with-footer`]: this.showSlotFooter\r\n        }\r\n      ];\r\n    },\r\n    classes() {\r\n      return [\r\n        `${prefixCls}`,\r\n        {\r\n          [`${prefixCls}-${this.size}`]: !!this.size,\r\n          [`${prefixCls}-border`]: this.border,\r\n          [`${prefixCls}-stripe`]: this.stripe,\r\n          [`${prefixCls}-with-fixed-top`]: !!this.height\r\n        }\r\n      ];\r\n    },\r\n    fixedHeaderClasses() {\r\n      return [\r\n        `${prefixCls}-fixed-header`,\r\n        {\r\n          [`${prefixCls}-fixed-header-with-empty`]: !this.rebuildData.length\r\n        }\r\n      ];\r\n    },\r\n    styles() {\r\n      let style = {};\r\n      if (this.height) {\r\n        const height =\r\n          this.isLeftFixed || this.isRightFixed\r\n            ? parseInt(this.height) + this.scrollBarWidth\r\n            : parseInt(this.height);\r\n        style.height = `${height}px`;\r\n      }\r\n      if (this.width) style.width = `${this.width}px`;\r\n      return style;\r\n    },\r\n    tableStyle() {\r\n      let style = {};      \r\n      if (this.tableWidth !== 0) {\r\n        let width = \"\";\r\n        if (this.bodyHeight === 0) {\r\n          width = this.tableWidth;\r\n        } else {\r\n          if (this.bodyHeight > this.bodyRealHeight) {\r\n            width = this.tableWidth;\r\n          } else {\r\n            width = this.tableWidth - this.scrollBarWidth;\r\n          }\r\n        }\r\n        //                    const width = this.bodyHeight === 0 ? this.tableWidth : this.tableWidth - this.scrollBarWidth;\r\n        style.width = `${width}px`;\r\n        // console.log(style.width)\r\n        // style.width = 'auto'\r\n      }\r\n      return style;\r\n    },\r\n    fixedTableStyle() {\r\n      let style = {};\r\n      let width = 0;\r\n      this.leftFixedColumns.forEach(col => {\r\n        if (col.fixed && col.fixed === \"left\") width += col._width;\r\n      });\r\n      style.width = `${width}px`;\r\n      return style;\r\n    },\r\n    fixedRightTableStyle() {\r\n      let style = {};\r\n      let width = 0;\r\n      this.rightFixedColumns.forEach(col => {\r\n        if (col.fixed && col.fixed === \"right\") width += col._width;\r\n      });\r\n      width += this.scrollBarWidth;\r\n      style.width = `${width}px`;\r\n      return style;\r\n    },\r\n    bodyStyle() {\r\n      let style = {};\r\n      if (this.bodyHeight !== 0) {\r\n        // add a height to resolve scroll bug when browser has a scrollBar in fixed type and height prop\r\n        const height =\r\n          this.isLeftFixed || this.isRightFixed\r\n            ? this.bodyHeight + this.scrollBarWidth\r\n            : this.bodyHeight;\r\n        style.height = `${height}px`;\r\n      }\r\n      return style;\r\n    },\r\n    fixedBodyStyle() {\r\n      let style = {};\r\n      if (this.bodyHeight !== 0) {\r\n        let height = this.bodyHeight + this.scrollBarWidth - 1;\r\n\r\n        // #2102 里，如果 Table 没有设置 width，而是集成父级的 width，固定列也应该不包含滚动条高度，所以这里直接计算表格宽度\r\n        const tableWidth = parseInt(getStyle(this.$el, \"width\")) - 1;\r\n        if (\r\n          (this.width && this.width < this.tableWidth) ||\r\n          tableWidth < this.tableWidth\r\n        ) {\r\n          height = this.bodyHeight;\r\n        }\r\n        //                    style.height = this.scrollBarWidth > 0 ? `${this.bodyHeight}px` : `${this.bodyHeight - 1}px`;\r\n        style.height =\r\n          this.scrollBarWidth > 0 ? `${height}px` : `${height - 1}px`;\r\n      }\r\n      return style;\r\n    },\r\n    leftFixedColumns() {\r\n      let left = [];\r\n      let other = [];\r\n      this.cloneColumns.forEach(col => {\r\n        if (col.fixed && col.fixed === \"left\") {\r\n          left.push(col);\r\n        } else {\r\n          other.push(col);\r\n        }\r\n      });\r\n      return left.concat(other);\r\n    },\r\n    rightFixedColumns() {\r\n      let right = [];\r\n      let other = [];\r\n      this.cloneColumns.forEach(col => {\r\n        if (col.fixed && col.fixed === \"right\") {\r\n          right.push(col);\r\n        } else {\r\n          other.push(col);\r\n        }\r\n      });\r\n      return right.concat(other);\r\n    },\r\n    isLeftFixed() {\r\n      return this.columns.some(col => col.fixed && col.fixed === \"left\");\r\n    },\r\n    isRightFixed() {\r\n      return this.columns.some(col => col.fixed && col.fixed === \"right\");\r\n    }\r\n  },\r\n  methods: {\r\n    rowClsName(index) {\r\n      return this.rowClassName(this.data[index], index);\r\n    },\r\n    handleResize() {\r\n    this.$nextTick(() => {\r\n      let tableWidth = 0;\r\n      const allWidth = !this.columns.some(cell => !cell.width); // each column set a width\r\n      if (allWidth) {\r\n        this.tableWidth = this.columns\r\n          .map(cell => cell.width)\r\n          .reduce((a, b) => a + b, 0);\r\n      } \r\n      //else {\r\n        // this.tableWidth = parseInt(getStyle(this.$refs.body, \"width\")) - 1;\r\n      //}        \r\n      // if(this.tableWidth!=0 )//非0,说明已经计算好了，不要再重新计算了\r\n      //     return\r\n      // this.columnsWidth = {};\r\n\r\n      if (!this.$refs.tbody) return;\r\n      this.$nextTick(() => {\r\n        let columnsWidth = {};\r\n        let autoWidthIndex = -1;\r\n        if (allWidth)\r\n          autoWidthIndex = this.cloneColumns.findIndex(cell => !cell.width); //todo 这行可能有问题                      \r\n\r\n        //\r\n        const $warrperdiv = this.$refs.header.parentNode.parentNode;\r\n    \r\n        if (this.data.length) {\r\n          const $bodyTr = this.$refs.tbody.$el.querySelectorAll(\"tbody tr\");\r\n          const $headTr = this.$refs.header.children[0].querySelectorAll(\"tr\");\r\n          // const $headTr = this.$refs.thead.$el.querySelectorAll(\"thead tr\");            \r\n                     \r\n          let $td = $headTr[0].children;                         \r\n          let autoColNum = $td.length;\r\n          //从后往前找到不是fixed width的第一个，将最后的宽度倒减给它，保证宽度一致性\r\n          let lastAutoWidth;\r\n          let lastIndex;\r\n          let autoTotalMinWidth = parseInt(getStyle($warrperdiv, \"width\"));;\r\n          for (let i = 0; i < $td.length; i++) {\r\n            let column = this.cloneColumns[i];\r\n            if (column.width) {\r\n              autoTotalMinWidth = autoTotalMinWidth-column.width;\r\n              autoColNum--;\r\n            }else{\r\n              lastIndex = i;//last index\r\n            }\r\n          }\r\n\r\n          let minWidthperCol = Math.floor(autoTotalMinWidth/autoColNum-10);\r\n        //   let minWidthperCol = autoTotalMinWidth/autoColNum-10;\r\n          \r\n          for (let j = 0; j < $td.length; j++) {\r\n            // can not use forEach in Firefox\r\n            let column2 = this.cloneColumns[j];\r\n            let width = parseInt(getStyle($td[j], \"width\")) + 0;\r\n            // let width = Math.floor(getStyle($td[j], \"width\")) + 1;\r\n            //默认Auto\r\n            width = width>minWidthperCol?width:minWidthperCol;                          \r\n            if (column2.width) {//固定宽度\r\n              width = column2.width;\r\n            }else if(j==lastIndex){\r\n              width = autoTotalMinWidth-5;//最后一列就是剩下的宽度\r\n            }else {//自动宽度\r\n              autoTotalMinWidth -= width\r\n            }              \r\n            this.cloneColumns[j]._width = width;            \r\n            columnsWidth[column2._index] = {\r\n              width: width\r\n            };\r\n          }\r\n          \r\n          if($bodyTr.length!=0){\r\n            $td = $bodyTr[0].children;              \r\n            for(let j=0;j<$td.length;j++){                  \r\n                let column = this.cloneColumns[j];                  \r\n                let width = parseInt(getStyle($td[j], \"width\")) + 0;\r\n                // console.log('body['+j+']width=' +width)\r\n                if (column.width) width = column.width;                  \r\n                width = width > this.cloneColumns[j]._width?width:this.cloneColumns[j]._width;//使用大的width                                    \r\n                this.cloneColumns[j]._width = width;                  \r\n                columnsWidth[column._index] = {\r\n                   width: width\r\n                };                  \r\n            }\r\n          }\r\n\r\n          //计算tableWidth长度\r\n          for(let j=0;j<$td.length;j++){ \r\n            let column = this.cloneColumns[j];\r\n            tableWidth+=columnsWidth[column._index].width\r\n          }\r\n          \r\n          this.columnsWidth = columnsWidth;\r\n          // console.log(columnsWidth)\r\n           this.tableWidth = tableWidth;\r\n        }     \r\n         \r\n          //console.log(\"this.tableWidth=\"+this.tableWidth)\r\n      });\r\n      // get table real height,for fixed when set height prop,but height < table's height,show scrollBarWidth\r\n      this.bodyRealHeight = parseInt(\r\n        getStyle(this.$refs.tbody.$el, \"height\")\r\n      );\r\n    });\r\n    },\r\n    handleMouseIn(_index) {\r\n      if (this.disabledHover) return;\r\n      if (this.objData[_index]._isHover) return;\r\n      this.objData[_index]._isHover = true;\r\n    },\r\n    handleMouseOut(_index) {\r\n      if (this.disabledHover) return;\r\n      this.objData[_index]._isHover = false;\r\n    },\r\n    // 通用处理 highlightCurrentRow 和 clearCurrentRow\r\n    handleCurrentRow(type, _index) {\r\n      let oldIndex = -1;\r\n      for (let i in this.objData) {\r\n        if (this.objData[i]._isHighlight) {\r\n          oldIndex = parseInt(i);\r\n          this.objData[i]._isHighlight = false;\r\n        }\r\n      }\r\n      if (type === \"highlight\") this.objData[_index]._isHighlight = true;\r\n      const oldData =\r\n        oldIndex < 0\r\n          ? null\r\n          : JSON.parse(JSON.stringify(this.objData[_index].ref));\r\n      const newData =\r\n        type === \"highlight\"\r\n          ? JSON.parse(JSON.stringify(this.objData[_index].ref))\r\n          : null;\r\n      this.$emit(\"on-current-change\", newData, oldData);\r\n    },\r\n    highlightCurrentRow(_index) {\r\n      if (!this.highlightRow || this.objData[_index]._isHighlight) return;\r\n      this.handleCurrentRow(\"highlight\", _index);\r\n    },\r\n    clearCurrentRow() {\r\n      if (!this.highlightRow) return;\r\n      this.handleCurrentRow(\"clear\");\r\n    },\r\n    clickCurrentRow(_index) {\r\n      this.highlightCurrentRow(_index);\r\n      // console.log(this.objData[_index]);\r\n      this.$emit(\"on-row-click\", this.objData[_index].ref, _index);\r\n    },\r\n    dblclickCurrentRow(_index) {\r\n      this.highlightCurrentRow(_index);\r\n      this.$emit(\"on-row-dblclick\", this.objData[_index].ref, _index);\r\n    },\r\n    getSelection() {\r\n      let selections = [];\r\n      let selectionIndexes = [];\r\n      for (let i in this.objData) {\r\n        if (this.objData[i]._isChecked) {\r\n          selectionIndexes.push(parseInt(i));\r\n          selections.push(this.objData[i].ref);\r\n        }\r\n      }\r\n      return selections;\r\n    },\r\n    toggleSelect(_index) {\r\n      let data = {};\r\n\r\n      for (let i in this.objData) {\r\n        if (parseInt(i) === _index) {\r\n          data = this.objData[i];\r\n          break;\r\n        }\r\n      }\r\n      const status = !data._isChecked;\r\n\r\n      this.objData[_index]._isChecked = status;\r\n\r\n      const selection = this.getSelection();\r\n      this.$emit(\r\n        status ? \"on-select\" : \"on-select-cancel\",\r\n        selection,\r\n        this.objData[_index].ref\r\n      );\r\n      this.$emit(\"on-selection-change\", selection);\r\n    },\r\n    toggleExpand(_index) {\r\n      let data = {};\r\n      for (let i in this.objData) {\r\n        if (parseInt(i) === _index) {\r\n          data = this.objData[i];\r\n          break;\r\n        }\r\n      }\r\n      const status = !data._isExpanded;\r\n      this.objData[_index]._isExpanded = status;\r\n      this.$emit(\r\n        \"on-expand\",\r\n        JSON.parse(JSON.stringify(this.objData[_index].ref)),\r\n        status\r\n      );\r\n    },\r\n    toggleTree(_index) {\r\n      let data = {};\r\n      // let _currentIndex = _index;\r\n      for (let i in this.objData) {\r\n        if (parseInt(i) === _index) {\r\n          data = this.objData[i];\r\n          break;\r\n        }\r\n      }\r\n      const status = !data._isFolded;\r\n      this.objData[_index]._isFolded = status;\r\n      //modify origin data fold status 修改data时不再refreshfold状态\r\n      this.rebuildData[_index].ref._unfolded = !status;\r\n      //如果父节点fold，则它的children也要全部fold,直接修改源数据\r\n      // debugger\r\n      if (this.objData[_index]._isFolded) {\r\n        this.cascadeFold(this.rebuildData[_index].ref);\r\n        this.cascadeFold2(this.objData[_index]);\r\n      }\r\n      this.$emit(\"unfold-tree\", this.objData[_index].ref, status);\r\n    },\r\n    cascadeFold(objData) {\r\n      let children = objData.children;\r\n      if (children == null || children == undefined || children.length == 0) {\r\n        return;\r\n      }\r\n      for (let child of children) {\r\n        if (child != null) {\r\n          child._unfolded = false;\r\n        }\r\n        this.cascadeFold(child);\r\n      }\r\n    },\r\n    // 折叠子级树\r\n    cascadeFold2(objData) {\r\n      let children = objData.children;\r\n      if (children == null || children == undefined || children.length == 0) {\r\n        return;\r\n      }\r\n      for (let child of children) {\r\n        if (child != null) {\r\n          child._isFolded = true;\r\n        }\r\n        this.cascadeFold2(child);\r\n      }\r\n    },\r\n    selectAll(status) {\r\n      for (const data of this.rebuildData) {\r\n        if (this.objData[data._index]._isDisabled) {\r\n          continue;\r\n        } else {\r\n          this.objData[data._index]._isChecked = status;\r\n        }\r\n      }\r\n      const selection = this.getSelection();\r\n      if (status) {\r\n        this.$emit(\"on-select-all\", selection);\r\n      }\r\n      this.$emit(\"on-selection-change\", selection);\r\n    },\r\n    fixedHeader() {\r\n      if (this.height) {\r\n        this.$nextTick(() => {\r\n          const titleHeight =\r\n            parseInt(getStyle(this.$refs.title, \"height\")) || 0;\r\n          const headerHeight =\r\n            parseInt(getStyle(this.$refs.header, \"height\")) || 0;\r\n          const footerHeight =\r\n            parseInt(getStyle(this.$refs.footer, \"height\")) || 0;\r\n          this.bodyHeight =\r\n            this.height - titleHeight - headerHeight - footerHeight;\r\n        });\r\n      } else {\r\n        this.bodyHeight = 0;\r\n      }\r\n    },\r\n    hideColumnFilter() {\r\n      this.cloneColumns.forEach(col => (col._filterVisible = false));\r\n    },\r\n    handleBodyScroll(event) {\r\n      if (this.showHeader)\r\n        this.$refs.header.scrollLeft = event.target.scrollLeft;\r\n      if (this.isLeftFixed)\r\n        this.$refs.fixedBody.scrollTop = event.target.scrollTop;\r\n      if (this.isRightFixed)\r\n        this.$refs.fixedRightBody.scrollTop = event.target.scrollTop;\r\n      this.hideColumnFilter();\r\n    },\r\n    handleMouseWheel(event) {\r\n      const deltaX = event.deltaX;\r\n      const $body = this.$refs.body;\r\n\r\n      if (deltaX > 0) {\r\n        $body.scrollLeft = $body.scrollLeft + 10;\r\n      } else {\r\n        $body.scrollLeft = $body.scrollLeft - 10;\r\n      }\r\n    },\r\n    sortData(data, type, index) {\r\n      const key = this.cloneColumns[index].key;\r\n      data.sort((a, b) => {\r\n        if (this.cloneColumns[index].sortMethod) {\r\n          return this.cloneColumns[index].sortMethod(a[key], b[key], type);\r\n        } else {\r\n          if (type === \"asc\") {\r\n            return a[key] > b[key] ? 1 : -1;\r\n          } else if (type === \"desc\") {\r\n            return a[key] < b[key] ? 1 : -1;\r\n          }\r\n        }\r\n      });\r\n      return data;\r\n    },\r\n    handleSort(_index, type) {\r\n      const index = this.GetOriginalIndex(_index);\r\n      this.cloneColumns.forEach(col => (col._sortType = \"normal\"));\r\n\r\n      const key = this.cloneColumns[index].key;\r\n      if (this.cloneColumns[index].sortable !== \"custom\") {\r\n        // custom is for remote sort\r\n        if (type === \"normal\") {\r\n          this.rebuildData = this.makeDataWithFilter();\r\n        } else {\r\n          this.rebuildData = this.sortData(this.rebuildData, type, index);\r\n        }\r\n      }\r\n      this.cloneColumns[index]._sortType = type;\r\n\r\n      this.$emit(\"on-sort-change\", {\r\n        column: JSON.parse(\r\n          JSON.stringify(this.columns[this.cloneColumns[index]._index])\r\n        ),\r\n        key: key,\r\n        order: type\r\n      });\r\n    },\r\n    handleFilterHide(index) {\r\n      // clear checked that not filter now\r\n      if (!this.cloneColumns[index]._isFiltered)\r\n        this.cloneColumns[index]._filterChecked = [];\r\n    },\r\n    filterData(data, column) {\r\n      return data.filter(row => {\r\n        //如果定义了远程过滤方法则忽略此方法\r\n        if (typeof column.filterRemote === \"function\") return true;\r\n\r\n        let status = !column._filterChecked.length;\r\n        for (let i = 0; i < column._filterChecked.length; i++) {\r\n          status = column.filterMethod(column._filterChecked[i], row);\r\n          if (status) break;\r\n        }\r\n        return status;\r\n      });\r\n    },\r\n    filterOtherData(data, index) {\r\n      let column = this.cloneColumns[index];\r\n      if (typeof column.filterRemote === \"function\") {\r\n        column.filterRemote.call(\r\n          this.$parent,\r\n          column._filterChecked,\r\n          column.key,\r\n          column\r\n        );\r\n      }\r\n\r\n      this.cloneColumns.forEach((col, colIndex) => {\r\n        if (colIndex !== index) {\r\n          data = this.filterData(data, col);\r\n        }\r\n      });\r\n      return data;\r\n    },\r\n    handleFilter(index) {\r\n      const column = this.cloneColumns[index];\r\n      let filterData = this.makeDataWithSort();\r\n\r\n      // filter others first, after filter this column\r\n      filterData = this.filterOtherData(filterData, index);\r\n      this.rebuildData = this.filterData(filterData, column);\r\n\r\n      this.cloneColumns[index]._isFiltered = true;\r\n      this.cloneColumns[index]._filterVisible = false;\r\n      this.$emit(\"on-filter-change\", column);\r\n    },\r\n    /**\r\n     * #2832\r\n     * 应该区分当前表头的 column 是左固定还是右固定\r\n     * 否则执行到 $parent 时，方法的 index 与 cloneColumns 的 index 是不对应的\r\n     * 左固定和右固定，要区分对待\r\n     * 所以，此方法用来获取正确的 index\r\n     * */\r\n    GetOriginalIndex(_index) {\r\n      return this.cloneColumns.findIndex(item => item._index === _index);\r\n    },\r\n    handleFilterSelect(_index, value) {\r\n      const index = this.GetOriginalIndex(_index);\r\n      this.cloneColumns[index]._filterChecked = [value];\r\n      this.handleFilter(index);\r\n    },\r\n    handleFilterReset(_index) {\r\n      const index = this.GetOriginalIndex(_index);\r\n      this.cloneColumns[index]._isFiltered = false;\r\n      this.cloneColumns[index]._filterVisible = false;\r\n      this.cloneColumns[index]._filterChecked = [];\r\n\r\n      let filterData = this.makeDataWithSort();\r\n      filterData = this.filterOtherData(filterData, index);\r\n      this.rebuildData = filterData;\r\n      this.$emit(\"on-filter-change\", this.cloneColumns[index]);\r\n    },\r\n    makeDataWithSort() {\r\n      let data = this.makeData();\r\n      let sortType = \"normal\";\r\n      let sortIndex = -1;\r\n      let isCustom = false;\r\n\r\n      for (let i = 0; i < this.cloneColumns.length; i++) {\r\n        if (this.cloneColumns[i]._sortType !== \"normal\") {\r\n          sortType = this.cloneColumns[i]._sortType;\r\n          sortIndex = i;\r\n          isCustom = this.cloneColumns[i].sortable === \"custom\";\r\n          break;\r\n        }\r\n      }\r\n      if (sortType !== \"normal\" && !isCustom)\r\n        data = this.sortData(data, sortType, sortIndex);\r\n      return data;\r\n    },\r\n    makeDataWithFilter() {\r\n      let data = this.makeData();\r\n      this.cloneColumns.forEach(col => (data = this.filterData(data, col)));\r\n      return data;\r\n    },\r\n    makeDataWithSortAndFilter() {\r\n      let data = this.makeDataWithSort();\r\n      this.cloneColumns.forEach(col => (data = this.filterData(data, col)));\r\n      return data;\r\n    },\r\n    addRowIsAttribute(newRow) {\r\n      newRow._isHover = false;\r\n      if (newRow._disabled) {\r\n        newRow._isDisabled = newRow._disabled;\r\n      } else {\r\n        newRow._isDisabled = false;\r\n      }\r\n      if (newRow._checked) {\r\n        newRow._isChecked = newRow._checked;\r\n      } else {\r\n        newRow._isChecked = false;\r\n      }\r\n      if (newRow._expanded) {\r\n        newRow._isExpanded = newRow._expanded;\r\n      } else {\r\n        newRow._isExpanded = false;\r\n      }\r\n      if (newRow._highlight) {\r\n        newRow._isHighlight = newRow._highlight;\r\n      } else {\r\n        newRow._isHighlight = false;\r\n      }\r\n      if (newRow._unfolded) {\r\n        newRow._isFolded = !newRow._unfolded;\r\n      } else {\r\n        newRow._isFolded = true;\r\n      }\r\n      return newRow;\r\n    },\r\n    makeData() {\r\n      //创建表格Data\r\n      //makeData need to unfold the children node to table data\r\n      let root = this.data;\r\n      let data = [];\r\n      let dataRow;\r\n      let currentIndex = 0;\r\n      let rowKey = 0;\r\n      root.forEach((row, index) => {\r\n        if (row.hasOwnProperty(\"children\")) {\r\n          let treeStack = new Array();\r\n          let temp = { originData: row, makeData: null };\r\n          treeStack.push(temp);\r\n          //Deep fist travel children Tree\r\n          while (treeStack.length != 0) {\r\n            const obj = treeStack.pop();\r\n            const parentRow = obj.originData;\r\n            const dataRowParent = obj.makeData;\r\n            dataRow = this.deepCopyWithOutParent(parentRow);\r\n            if (typeof dataRowParent != \"undefined\" && dataRowParent != null) {\r\n              dataRowParent.children.push(dataRow);\r\n              dataRow.parent = dataRowParent;\r\n            }\r\n            dataRow._rowKey = rowKey++;\r\n            dataRow._index = currentIndex;\r\n            dataRow.ref = parentRow; //增加对原数据的引用，方便后续操作\r\n            data[currentIndex++] = dataRow;\r\n            if (parentRow.hasOwnProperty(\"children\")) {\r\n              dataRow.children = [];\r\n              for (let i = parentRow.children.length - 1; i >= 0; i--) {\r\n                treeStack.push({\r\n                  originData: parentRow.children[i],\r\n                  makeData: dataRow\r\n                });\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          dataRow = this.deepCopyWithOutParent(row);\r\n          dataRow._rowKey = rowKey++;\r\n          dataRow._index = currentIndex;\r\n          dataRow.ref = row; //增加对原数据的引用，方便后续操作\r\n          data[currentIndex++] = dataRow;\r\n        }\r\n      });\r\n      //   console.log(data);\r\n      return data;\r\n    },\r\n    makeObjData() {\r\n      // let data = {};\r\n      // let newIndex = 0;\r\n      // this.data.forEach((row, index) => {\r\n      //   let root = this.addRowIsAttribute(deepCopy(row));\r\n      //   root.ref = row;\r\n      //   if (root.hasOwnProperty(\"children\")) {\r\n      //     //遍历\r\n      //     let treeStack = new Array();\r\n      //     treeStack.push(root);\r\n      //     while (treeStack.length != 0) {\r\n      //       const parentRow = treeStack.pop();\r\n      //       data[newIndex] = this.addRowIsAttribute(deepCopy(parentRow)); //输出\r\n      //       // data[newIndex].ref = parentRow;\r\n      //       newIndex++;\r\n      //       if (parentRow.hasOwnProperty(\"children\")) {\r\n      //         //逆序遍历数组\r\n      //         for (let i = parentRow.children.length - 1; i >= 0; i--) {\r\n      //           parentRow.children[i].parent = parentRow;\r\n      //           treeStack.push(parentRow.children[i]);\r\n      //         }\r\n      //       }\r\n      //     }\r\n      //   } else {\r\n      //     data[newIndex++] = root;\r\n      //   }\r\n      //   //Deep fist travel children Tree\r\n      // });\r\n      // console.log(data);\r\n      let data = {};\r\n      this.makeData().forEach((row, index) => {\r\n        data[index] = this.addRowIsAttribute(row);\r\n      });\r\n      return data;\r\n    },\r\n    makeColumns() {\r\n      let columns = deepCopy(this.columns);\r\n      let left = [];\r\n      let right = [];\r\n      let center = [];\r\n\r\n      columns.forEach((column, index) => {\r\n        column._index = index;\r\n        column._columnKey = columnKey++;\r\n        column._width = column.width ? column.width : \"\"; // update in handleResize()\r\n        column._sortType = \"normal\";\r\n        column._filterVisible = false;\r\n        column._isFiltered = false;\r\n        column._filterChecked = [];\r\n\r\n        if (\"filterMultiple\" in column) {\r\n          column._filterMultiple = column.filterMultiple;\r\n        } else {\r\n          column._filterMultiple = true;\r\n        }\r\n        if (\"filteredValue\" in column) {\r\n          column._filterChecked = column.filteredValue;\r\n          column._isFiltered = true;\r\n        }\r\n\r\n        if (\"sortType\" in column) {\r\n          column._sortType = column.sortType;\r\n        }\r\n\r\n        if (column.fixed && column.fixed === \"left\") {\r\n          left.push(column);\r\n        } else if (column.fixed && column.fixed === \"right\") {\r\n          right.push(column);\r\n        } else {\r\n          center.push(column);\r\n        }\r\n      });\r\n      return left.concat(center).concat(right);\r\n    },\r\n    exportCsv(params) {\r\n      if (params.filename) {\r\n        if (params.filename.indexOf(\".csv\") === -1) {\r\n          params.filename += \".csv\";\r\n        }\r\n      } else {\r\n        params.filename = \"table.csv\";\r\n      }\r\n\r\n      let columns = [];\r\n      let datas = [];\r\n      if (params.columns && params.data) {\r\n        columns = params.columns;\r\n        datas = params.data;\r\n      } else {\r\n        columns = this.columns;\r\n        if (!(\"original\" in params)) params.original = true;\r\n        datas = params.original ? this.data : this.rebuildData;\r\n      }\r\n\r\n      let noHeader = false;\r\n      if (\"noHeader\" in params) noHeader = params.noHeader;\r\n\r\n      const data = Csv(columns, datas, params, noHeader);\r\n      if (params.callback) params.callback(data);\r\n      else ExportCsv.download(params.filename, data);\r\n    },\r\n    deepCopyWithOutParent(data) {\r\n      const t = this.typeOf(data);\r\n      let o;\r\n      if (t === \"array\") {\r\n        o = [];\r\n      } else if (t === \"object\") {\r\n        o = {};\r\n      } else {\r\n        return data;\r\n      }\r\n\r\n      if (t === \"array\") {\r\n        for (let i = 0; i < data.length; i++) {\r\n          o.push(this.deepCopyWithOutParent(data[i]));\r\n        }\r\n      } else if (t === \"object\") {\r\n        for (let i in data) {\r\n          if (i != \"parent\" && i != \"children\") {\r\n            o[i] = this.deepCopyWithOutParent(data[i]);\r\n          } else {\r\n            o[i] = data[i];\r\n          }\r\n        }\r\n      }\r\n      return o;\r\n    },\r\n    typeOf(obj) {\r\n      const toString = Object.prototype.toString;\r\n      const map = {\r\n        \"[object Boolean]\": \"boolean\",\r\n        \"[object Number]\": \"number\",\r\n        \"[object String]\": \"string\",\r\n        \"[object Function]\": \"function\",\r\n        \"[object Array]\": \"array\",\r\n        \"[object Date]\": \"date\",\r\n        \"[object RegExp]\": \"regExp\",\r\n        \"[object Undefined]\": \"undefined\",\r\n        \"[object Null]\": \"null\",\r\n        \"[object Object]\": \"object\"\r\n      };\r\n      return map[toString.call(obj)];\r\n    }\r\n  },\r\n  created() {\r\n    if (!this.context) this.currentContext = this.$parent;\r\n    this.showSlotHeader = this.$slots.header !== undefined;\r\n    this.showSlotFooter = this.$slots.footer !== undefined;\r\n    this.rebuildData = this.makeDataWithSortAndFilter();\r\n  },\r\n  mounted() {\r\n    this.handleResize();\r\n    this.fixedHeader();\r\n    this.$nextTick(() => (this.ready = true));\r\n\r\n    on(window, \"resize\", this.handleResize);\r\n    this.observer = elementResizeDetectorMaker();\r\n    this.observer.listenTo(this.$el, this.handleResize);\r\n\r\n    this.$on(\"on-visible-change\", val => {\r\n      if (val) {\r\n        this.handleResize();\r\n        this.fixedHeader();\r\n      }\r\n    });\r\n  },\r\n  beforeDestroy() {\r\n    off(window, \"resize\", this.handleResize);\r\n    this.observer.removeListener(this.$el, this.handleResize);\r\n  },\r\n  watch: {\r\n    data: {\r\n      handler() {\r\n        const oldDataLen = this.rebuildData.length;\r\n        this.objData = this.makeObjData();\r\n        this.rebuildData = this.makeDataWithSortAndFilter();\r\n        this.handleResize();\r\n        if (!oldDataLen) {\r\n          this.fixedHeader();\r\n        }\r\n      },\r\n      deep: true\r\n    },\r\n    columns: {\r\n      handler() {\r\n        // todo 这里有性能问题，可能是左右固定计算属性影响的\r\n        this.cloneColumns = this.makeColumns();\r\n        this.rebuildData = this.makeDataWithSortAndFilter();\r\n        this.handleResize();\r\n      },\r\n      deep: true\r\n    },\r\n    height() {\r\n      this.fixedHeader();\r\n    }\r\n  }\r\n};\r\n</script>\r\n"]}]}